// ../../node_modules/@needle-di/core/dist/utils.js
function isClassLike(target) {
  return typeof target === "function";
}
function getParentClasses(target) {
  const parentClasses = [];
  let currentClass = target;
  while (Object.getPrototypeOf(currentClass).name) {
    const parentClass = Object.getPrototypeOf(currentClass);
    parentClasses.push(parentClass);
    currentClass = parentClass;
  }
  return parentClasses;
}
function assertPresent(value) {
  if (value === null || value === void 0) {
    throw Error(`Expected value to be not null or undefined`);
  }
  return value;
}
function windowedSlice(array, step = 2) {
  const result = [];
  array.some((_, i) => {
    if (i + step > array.length)
      return true;
    result.push(array.slice(i, i + step));
  });
  return result;
}
async function retryOn(errorClass, block, onError) {
  while (true) {
    try {
      return await block();
    } catch (error) {
      if (!(error instanceof errorClass)) {
        throw error;
      }
      await onError(error);
    }
  }
}
function assertSingle(array, errorProvider) {
  if (array.length > 1) {
    throw errorProvider();
  }
  const first = array.at(0);
  if (first === void 0) {
    throw errorProvider();
  }
  return first;
}
function assertNever(_) {
  throw new Error("invalid state");
}
async function promiseTry(block) {
  return await new Promise((resolve) => resolve(block()));
}

// ../../node_modules/@needle-di/core/dist/providers.js
function isConstructorProvider(provider) {
  return isClassLike(provider);
}
function isClassProvider(provider) {
  return "provide" in provider && "useClass" in provider;
}
function isValueProvider(provider) {
  return "provide" in provider && "useValue" in provider;
}
function isFactoryProvider(provider) {
  return "provide" in provider && "useFactory" in provider;
}
function isAsyncProvider(provider) {
  return isFactoryProvider(provider) && provider.async === true;
}
function isExistingProvider(provider) {
  return "provide" in provider && "useExisting" in provider;
}
function isMultiProvider(provider) {
  return "provide" in provider && "multi" in provider && provider.multi === true;
}

// ../../node_modules/@needle-di/core/dist/tokens.js
var InjectionToken = class {
  description;
  options;
  constructor(description, options) {
    this.description = description;
    this.options = options;
  }
  toString() {
    return `InjectionToken "${String(this.description)}"`;
  }
};
function isClassToken(token) {
  return isClassLike(token);
}
function isInjectionToken(token) {
  return token instanceof InjectionToken;
}
function toString(token) {
  if (isClassLike(token)) {
    return token.name;
  } else if (typeof token === "symbol") {
    return token.description ?? String(token);
  } else if (token instanceof InjectionToken) {
    return token.toString();
  } else {
    return token;
  }
}
function getToken(provider) {
  return isConstructorProvider(provider) ? provider : provider.provide;
}

// ../../node_modules/@needle-di/core/dist/decorators.js
function injectable() {
  return (target) => {
    getParentClasses(target).forEach((parentClass) => {
      if (!Object.getOwnPropertyDescriptor(parentClass, injectableSymbol)) {
        Object.defineProperty(parentClass, injectableSymbol, {
          value: [target],
          writable: true,
          enumerable: false
        });
      } else {
        const injectableParentClass = parentClass;
        injectableParentClass[injectableSymbol] = [...injectableParentClass[injectableSymbol], target];
      }
    });
    Object.defineProperty(target, injectableSymbol, {
      value: [target],
      writable: true
    });
  };
}
var injectableSymbol = Symbol("injectable");
function isInjectable(target) {
  return target.hasOwnProperty(injectableSymbol);
}
function getInjectableTargets(target) {
  return target[injectableSymbol];
}

// ../../node_modules/@needle-di/core/dist/factory.js
var Factory = class {
  container;
  underConstruction = [];
  constructor(container) {
    this.container = container;
  }
  construct(provider, token) {
    if (isAsyncProvider(provider)) {
      throw new AsyncProvidersInSyncInjectionContextError(token);
    }
    try {
      if (this.underConstruction.includes(provider)) {
        const dependencyGraph = [...this.underConstruction, provider].map(getToken).map(toString);
        throw new CircularDependencyError(dependencyGraph);
      }
      this.underConstruction.push(provider);
      return this.doConstruct(provider);
    } finally {
      this.underConstruction.pop();
    }
  }
  async constructAsync(provider) {
    try {
      if (this.underConstruction.includes(provider)) {
        const dependencyGraph = [...this.underConstruction, provider].map(getToken).map(toString);
        throw new CircularDependencyError(dependencyGraph);
      }
      this.underConstruction.push(provider);
      if (isAsyncProvider(provider)) {
        return [await provider.useFactory(this.container)];
      }
      if (isClassProvider(provider) || isConstructorProvider(provider)) {
        const create = isConstructorProvider(provider) ? () => [new provider()] : () => [new provider.useClass()];
        return retryOn(AsyncProvidersInSyncInjectionContextError, async () => create(), async (error) => {
          await this.container.getAsync(error.token, { multi: true, optional: true });
        });
      }
      return this.doConstruct(provider);
    } finally {
      this.underConstruction.pop();
    }
  }
  doConstruct(provider) {
    if (isConstructorProvider(provider)) {
      return [new provider()];
    } else if (isClassProvider(provider)) {
      return [new provider.useClass()];
    } else if (isValueProvider(provider)) {
      return [provider.useValue];
    } else if (isFactoryProvider(provider)) {
      return [provider.useFactory(this.container)];
    } else if (isExistingProvider(provider)) {
      return this.container.get(provider.useExisting, { multi: true });
    }
    return assertNever(provider);
  }
};
var AsyncProvidersInSyncInjectionContextError = class extends Error {
  token;
  constructor(token) {
    super(`Some providers for token ${toString(token)} are async, please use injectAsync() or container.getAsync() instead`);
    this.token = token;
  }
};
var CircularDependencyError = class extends Error {
  constructor(graph) {
    super(`Detected circular dependency: ${graph.join(" -> ")}. Please change your dependency graph or use lazy injection instead.`);
  }
};

// ../../node_modules/@needle-di/core/dist/context.js
function inject(token, options) {
  try {
    return _currentContext.run((container) => container.get(token, options));
  } catch (error) {
    if (error instanceof NeedsInjectionContextError && options?.optional === true) {
      return void 0;
    }
    throw error;
  }
}
function injectAsync(token, options) {
  try {
    if (options?.lazy) {
      return _currentContext.run((container) => container.getAsync(token, { ...options, lazy: true }));
    }
    return _currentContext.runAsync((container) => container.getAsync(token, { ...options, lazy: false }));
  } catch (error) {
    if (error instanceof NeedsInjectionContextError && options?.optional === true) {
      return Promise.resolve(void 0);
    }
    return Promise.reject(error);
  }
}
var GlobalContext = class {
  run() {
    throw new NeedsInjectionContextError();
  }
  runAsync() {
    throw new NeedsInjectionContextError();
  }
};
var InjectionContext = class {
  container;
  constructor(container) {
    this.container = container;
  }
  run(block) {
    const originalContext = _currentContext;
    try {
      _currentContext = this;
      return block(this.container);
    } finally {
      _currentContext = originalContext;
    }
  }
  async runAsync(block) {
    const originalContext = _currentContext;
    try {
      _currentContext = this;
      return await block(this.container);
    } finally {
      _currentContext = originalContext;
    }
  }
};
var _currentContext = new GlobalContext();
function injectionContext(container) {
  return new InjectionContext(container);
}
var NeedsInjectionContextError = class extends Error {
  constructor() {
    super(`You can only invoke inject() or injectAsync() within an injection context`);
  }
};

// ../../node_modules/@needle-di/core/dist/container.js
var Container = class _Container {
  providers = /* @__PURE__ */ new Map();
  singletons = /* @__PURE__ */ new Map();
  parent;
  factory;
  constructor(parent) {
    this.parent = parent;
    this.factory = new Factory(this);
    this.bind({
      provide: _Container,
      useValue: this
    });
  }
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  bindAll(...providers) {
    providers.forEach((it) => this.bind(it));
    return this;
  }
  /**
   * Binds a provider to this container.
   *
   * {@link https://needle-di.io/concepts/binding.html#binding}
   */
  bind(provider) {
    const token = getToken(provider);
    if (isExistingProvider(provider) && provider.provide === provider.useExisting) {
      throw Error(`The provider for token ${toString(token)} with "useExisting" cannot refer to itself.`);
    }
    if (!isExistingProvider(provider) && this.singletons.has(token)) {
      throw Error(`Cannot bind a new provider for ${toString(token)}, since the existing provider was already constructed.`);
    }
    if (isExistingProvider(provider) && isMultiProvider(provider) && this.existingProviderAlreadyProvided(token, provider.useExisting)) {
      return this;
    }
    const providers = this.providers.get(token) ?? [];
    const multi = isMultiProvider(provider);
    if (multi && providers.some((it) => !isMultiProvider(it))) {
      throw Error(`Cannot bind ${toString(token)} as multi-provider, since there is already a provider which is not a multi-provider.`);
    } else if (!multi && providers.some((it) => isMultiProvider(it))) {
      if (!providers.every(isExistingProvider)) {
        throw Error(`Cannot bind ${toString(token)} as provider, since there are already provider(s) that are multi-providers.`);
      }
    }
    this.providers.set(token, multi ? [...providers, provider] : [provider]);
    if (isClassToken(token) && (isClassProvider(provider) || isConstructorProvider(provider))) {
      windowedSlice([token, ...getParentClasses(token)]).forEach(([childClass, parentClass]) => {
        const parentProvider = {
          provide: parentClass,
          useExisting: childClass,
          multi: true
        };
        const existingParentProviders = this.providers.get(parentClass) ?? [];
        if (!this.existingProviderAlreadyProvided(parentClass, childClass)) {
          this.providers.set(parentClass, [...existingParentProviders, parentProvider]);
        }
      });
    }
    return this;
  }
  get(token, options) {
    const lazy = options?.lazy ?? false;
    if (lazy) {
      return () => this.get(token, { ...options, lazy: false });
    }
    this.autoBindIfNeeded(token);
    const optional = options?.optional ?? false;
    if (!this.providers.has(token)) {
      if (this.parent) {
        return this.parent.get(token, { ...options, lazy: false });
      }
      if (optional) {
        return void 0;
      }
      throw Error(`No provider(s) found for ${toString(token)}`);
    }
    const providers = assertPresent(this.providers.get(token));
    if (!this.singletons.has(token)) {
      injectionContext(this).run(() => {
        const values = providers.flatMap((provider) => this.factory.construct(provider, token));
        this.singletons.set(token, values);
      });
    }
    const singletons = assertPresent(this.singletons.get(token));
    const multi = options?.multi ?? false;
    if (multi) {
      return singletons;
    } else {
      return assertSingle(singletons, () => Error(`Requesting a single value for ${toString(token)}, but multiple values were provided. Consider passing "{ multi: true }" to inject all values, or adjust your bindings accordingly.`));
    }
  }
  getAsync(token, options) {
    const lazy = options?.lazy ?? false;
    if (lazy) {
      return () => this.getAsync(token, { ...options, lazy: false });
    }
    return promiseTry(async () => {
      this.autoBindIfNeeded(token);
      const optional = options?.optional ?? false;
      if (!this.providers.has(token)) {
        if (optional) {
          return void 0;
        }
        throw Error(`No provider(s) found for ${toString(token)}`);
      }
      const providers = assertPresent(this.providers.get(token));
      if (!this.singletons.has(token)) {
        await injectionContext(this).runAsync(async () => {
          const values = await Promise.all(providers.map((it) => this.factory.constructAsync(it)));
          this.singletons.set(token, values.flat());
        });
      }
      const singletons = assertPresent(this.singletons.get(token));
      const multi = options?.multi ?? false;
      if (multi) {
        return singletons;
      } else {
        return assertSingle(singletons, () => new Error(`Requesting a single value for ${toString(token)}, but multiple values were provided. Consider passing "{ multi: true }" to inject all values, or adjust your bindings accordingly.`));
      }
    });
  }
  /**
   * Creates a child container.
   *
   * {@link https://needle-di.io/advanced/child-containers.html}
   */
  createChild() {
    return new _Container(this);
  }
  /**
   * Returns whether the container has one or more providers for this token.
   */
  has(token) {
    return this.providers.has(token);
  }
  autoBindIfNeeded(token) {
    if (this.singletons.has(token)) {
      return;
    }
    if (isClassToken(token) && isInjectable(token)) {
      const targetClasses = getInjectableTargets(token);
      targetClasses.filter((targetClass) => !this.providers.has(targetClass)).forEach((targetClass) => {
        this.bind({
          provide: targetClass,
          useClass: targetClass,
          multi: true
        });
      });
    } else if (!this.providers.has(token) && isInjectionToken(token) && token.options?.factory) {
      const async = token.options.async;
      if (!async) {
        this.bind({
          provide: token,
          async: false,
          useFactory: token.options.factory
        });
      } else if (async) {
        this.bind({
          provide: token,
          async: true,
          useFactory: token.options.factory
        });
      }
    }
  }
  existingProviderAlreadyProvided(token, existingToken) {
    return (this.providers.get(token) ?? []).some((it) => isExistingProvider(it) && it.provide === token && it.useExisting === existingToken);
  }
};
function bootstrap(token) {
  return new Container().get(token);
}
function bootstrapAsync(token) {
  return new Container().getAsync(token);
}
export {
  Container,
  InjectionToken,
  bootstrap,
  bootstrapAsync,
  inject,
  injectAsync,
  injectable
};
//# sourceMappingURL=@needle-di_core.js.map
